---
title: "Zig's Catch Pattern In JavaScript"
date: "2025-01-14"
slug: "zig-catch-pattern-in-js"
---

## How It Started

I was watching [injuly](https://injuly.in/)'s live video stream in the discord server [The Ziggurat](https://discord.gg/BwGez7Js) just for the vibe.
He was writing something in [Zig](https://ziglang.org/) - can't remember what - but what caught my attention was
Zig's error handling using [try](https://ziglang.org/documentation/master/#try) and [catch](https://ziglang.org/documentation/master/#catch).
I liked the way they handled errors and Immiediately wanted something similar in JavaScript. 

I find scoping of JavaScript's `try-catch` block quite annoying, It forces you to declare variable before 
using it. This blog is about How Zig's `catch` error handling pattern guided me remedy this scoping issue.

```typescript
let foo: string;
try {
  foo = await bar();
} catch(err: unknown) {
  // Handler error;
}
console.log(foo);
```

Above code is annoying, unless you don't mind huge `try-catch` blocks.

## Getting Inspired
Let's take a look at the Zig's error handling with `catch` with an <s>good</s> example.

```zig
const std = @import("std");

fn divide(a: i32, b: i32) !i32 {
    if (b == 0) {
        return error.DivisionByZero;
    }
    return a / b;
}

pub fn main() !void {
    // Example 1: Using catch to provide a default value
    const result1 = divide(10, 0) catch 0;
    std.debug.print("Result with default: {}\n", .{result1});  // prints 0

    // Example 2: Using catch to handle the error
    const result2 = divide(10, 0) catch |err| {
        std.debug.print("Oops! {}\n", .{err});
        return err;
    };
}
```

We are handling the error at the same place where we are calling the function.
No new scope, no bulky `try-catch` block and no new indentation. 

It's better than Rust's way(wait, I have an explanation for that). Rust does great for default values but 
if you want to handle error then you have to `match`, creating a new scope and one level of indentation.
But it looks more neat and clean though.

```rust
fn divide(a: i32, b: i32) -> Result<i32, &'static str> {
    if b == 0 {
        return Err("DivisionByZero");
    }
    Ok(a / b)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Example 1: Using unwrap_or to provide a default value
    let result1 = divide(10, 0).unwrap_or(0);
    println!("Result with default: {}", result1); // prints 0

    // Example 2: Using match to handle the error
    match divide(10, 0) {
        Ok(result) => println!("Result: {}", result),
        Err(err) => {
            println!("Oops! {}", err);
            return Err(err.into());
        }
    }

    Ok(())
}
```

## Zig's influence
I really wanted something similar in JavaScript. I tried creating classes and util functions, but did not work 
until I realized we already have something similar JavaScript, <i>It was staring me right in the face</i>.


To show Zig's way of error handling in JavaScript, I am going to do a gross thing, 
 make `divide()` function async(Now you know why **good** was striked out). I'll come back to it.


Here you go:
```typescript
async function divide(a, b) {
    if (b === 0) {
        throw new Error("DivisionByZero");
    }
    return a / b;
}

async function main() {
    // Example 1: Using a default value with .catch()
    let result1 = await divide(10, 0).catch((_) => 0);
    console.log(`Result with default: ${result1}`); // prints 0

    // Example 2: Handling the error explicitly
    const result2 = await divide(10, 0).catch((err) => {
      console.log(`Oops! ${err.message}`);
      throw err;
    });
    console.log(`Result: ${result2}`);
}

main();
```
I did not use `try-catch` block at all, 
It looks so like Zig's `catch` block. Practically, it's the same thing.


Making `divide()` async function is not alright. Not recommended. It was just to make the point.
Most of the time we(backend people) are dealing with async functions.

#### What about synchronous functions then?

```typescript
const $try = <T extends (...args: any[]) => any>(fn: T) => {
  const Try = class {
    constructor(private readonly value: T) { }

    catch(fn: (err: unknown) => ReturnType<T> | never): ReturnType<T> {
      try {
        return this.value()
      } catch (err) {
        return fn(err)
      }
    }
  }

  return new Try(fn)
}
```
`try` is a keyword in JavaScript. So have to settle for `$try` or `try_` whatever suits you.
`$try()` will return an anonymous class with a `catch()` method which takes a synchronous error handler.

```typescript
function divide(a, b) {
    if (b === 0) {
        throw new Error("DivisionByZero");
    }
    return a / b;
}

function main() {
    // Example 1: Using a default value with .catch()
    let result1 = $try(() => divide(10, 0)).catch((_) => 0);
    console.log(`Result with default: ${result1}`); // prints 0

    // Example 2: Handling the error explicitly
    const result2 = $try(() => divide(10, 0)).catch((err) => {
      console.log(`Oops! ${(err as any).message}`);
      throw err;
    });
    console.log(`Result: ${result2}`);
}

main();
```

It is not perfect though, It clutters the call site and you can't pass async functions to it as error handler.

I don't use it blindly or `try-catch` block is bad or anything.
What I am addressing here, could be considered as good practice or not, depends on the situation. 
I try out different styles and see if it makes more readable code.

<p style={{ 
    marginTop: '64px', 
    color: '#666666', 
    textAlign: 'center', 
    fontStyle: 'italic' 
}}>
  Don't Lose the Rhythm
</p>
